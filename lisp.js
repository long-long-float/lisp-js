// Generated by CoffeeScript 1.7.1
var Atom, List, Nil, Parser,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

Atom = (function() {
  function Atom(value) {
    this.value = value;
  }

  return Atom;

})();

Nil = (function(_super) {
  __extends(Nil, _super);

  function Nil() {
    return Nil.__super__.constructor.apply(this, arguments);
  }

  return Nil;

})(Atom);

List = (function() {
  function List(values, as_data) {
    this.values = values;
    this.as_data = as_data;
  }

  return List;

})();

Parser = (function() {
  function Parser() {}

  Parser.prototype.getChar = function() {
    return this.code[this.pos];
  };

  Parser.prototype.skip = function() {
    var _ref, _results;
    _results = [];
    while ((_ref = this.getChar()) != null ? _ref.match(/[ ]/) : void 0) {
      _results.push(this.pos++);
    }
    return _results;
  };

  Parser.prototype.isEOF = function() {
    return this.pos === this.code.length;
  };

  Parser.prototype.expects = function(pattern, throwing) {
    var valid;
    if (throwing == null) {
      throwing = true;
    }
    valid = (pattern instanceof RegExp && pattern.test(this.getChar())) || pattern === this.getChar();
    if (!valid && throwing) {
      throw "unexpected \"" + (this.getChar()) + "\", expects \"" + pattern + "\"";
    }
    return valid;
  };

  Parser.prototype.expects_str = function(str, throwing) {
    var valid;
    if (throwing == null) {
      throwing = true;
    }
    return valid = this.code.slice(this.pos, this.pos + str.length) === str;
  };

  Parser.prototype.forwards = function(pattern) {
    this.expects(pattern);
    return this.pos++;
  };

  Parser.prototype.forwards_str = function(str) {
    this.expects_str(str);
    return this.pos += str.length;
  };

  Parser.prototype.atom = function() {
    var c, num, str;
    c = this.getChar();
    if (this.expects(/[0-9]/, false)) {
      num = '';
      while (this.expects(/[0-9]/, false)) {
        num += this.getChar();
        this.pos++;
      }
      return new Atom(parseInt(num));
    }
    if (this.expects('"', false)) {
      this.forwards('"');
      str = '';
      while (!this.expects('"', false)) {
        str += this.getChar();
        this.pos++;
      }
      this.forwards('"');
      return new Atom(str);
    }
    if (this.expects_str('nil', false)) {
      this.forwards_str('nil');
      return new Nil;
    }
  };

  Parser.prototype.list = function(as_data) {
    var ret;
    this.forwards('(');
    ret = [];
    while (!this.expects(')', false)) {
      ret.push(this.expr());
      this.skip();
    }
    this.forwards(')');
    return new List(ret, as_data);
  };

  Parser.prototype.expr = function() {
    if (this.expects("'", false)) {
      this.forwards("'");
      return this.list(true);
    } else if (this.expects('(', false)) {
      return this.list(false);
    } else {
      return this.atom();
    }
  };

  Parser.prototype.program = function() {
    var ret;
    ret = [];
    while (!this.isEOF()) {
      ret.push(this.list());
    }
    return ret;
  };

  Parser.prototype.parse = function(code) {
    this.code = code;
    this.pos = 0;
    return this.program();
  };

  return Parser;

})();

this.Lisp = (function() {
  function Lisp() {}

  Lisp["eval"] = function(code) {
    var p;
    p = new Parser;
    return p.parse(code);
  };

  return Lisp;

})();
