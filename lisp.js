// Generated by CoffeeScript 1.10.0
(function() {
  var CallFun, Environment, Evaluator, Lambda, LispError, List, NameError, Nil, NotFunctionError, ParseError, SYMBOL_PATTERN, Symbol, T, currentEnv, envstack, error, isAtom, nil, t,
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  Symbol = (function() {
    function Symbol(name1, quoted1, pos1) {
      this.name = name1;
      this.quoted = quoted1;
      this.pos = pos1;
    }

    Symbol.prototype.toString = function() {
      return "" + (this.quoted ? "'" : "") + this.name;
    };

    return Symbol;

  })();

  Nil = (function() {
    function Nil() {
      this.values = [];
    }

    Nil.prototype.toString = function() {
      return 'nil';
    };

    return Nil;

  })();

  nil = new Nil;

  T = (function() {
    function T() {}

    T.prototype.toString = function() {
      return 't';
    };

    return T;

  })();

  t = new T;

  List = (function() {
    function List(values1) {
      this.values = values1;
    }

    List.prototype.toString = function() {
      return "(" + (this.values.map(function(v) {
        return v.toString();
      }).join(' ')) + ")";
    };

    return List;

  })();

  CallFun = (function() {
    function CallFun(funname1, args1) {
      this.funname = funname1;
      this.args = args1;
      this.values = [this.funname].concat(slice.call(this.args));
    }

    CallFun.prototype.toString = function() {
      return "(" + (this.values.map(function(v) {
        return v.toString();
      }).join(' ')) + ")";
    };

    return CallFun;

  })();

  Lambda = (function() {
    function Lambda(params, exprs) {
      this.params = params;
      this.exprs = exprs;
    }

    return Lambda;

  })();

  Environment = (function() {
    function Environment(variables) {
      this.variables = variables;
      this.macros = {};
    }

    Environment.prototype.get = function(name) {
      return this.variables[name];
    };

    Environment.prototype.set = function(name, val) {
      return this.variables[name] = val;
    };

    Environment.prototype.getMacro = function(name) {
      return this.macros[name];
    };

    Environment.prototype.setMacro = function(name, macro) {
      return this.macros[name] = macro;
    };

    return Environment;

  })();

  LispError = (function(superClass) {
    extend(LispError, superClass);

    function LispError(message) {
      this.message = message;
      this.name = this.constructor.name;
    }

    LispError.prototype.toString = function() {
      return "[object: " + this.name + "]";
    };

    return LispError;

  })(Error);

  ParseError = (function(superClass) {
    extend(ParseError, superClass);

    function ParseError() {
      return ParseError.__super__.constructor.apply(this, arguments);
    }

    return ParseError;

  })(LispError);

  NameError = (function(superClass) {
    extend(NameError, superClass);

    function NameError() {
      return NameError.__super__.constructor.apply(this, arguments);
    }

    return NameError;

  })(LispError);

  NotFunctionError = (function(superClass) {
    extend(NotFunctionError, superClass);

    function NotFunctionError() {
      return NotFunctionError.__super__.constructor.apply(this, arguments);
    }

    return NotFunctionError;

  })(LispError);

  isAtom = function(val) {
    return typeof val === 'string' || typeof val === 'number' || val instanceof Nil || val instanceof T;
  };

  envstack = [];

  currentEnv = function() {
    if (!(envstack.length > 0)) {
      throw "envstack is empty";
    }
    return envstack[envstack.length - 1];
  };

  error = function(klass, msg, pos) {
    throw new klass(("" + msg) + (pos != null ? " at " + pos.row + ":" + pos.column : ""));
  };

  SYMBOL_PATTERN = /[\w+\-*\/!#$%&=~^|<>?_]/;

  this.Parser = (function() {
    function Parser() {}

    Parser.prototype.skip = function() {
      var ref, results;
      results = [];
      while ((ref = this.code[this.pos]) != null ? ref.match(/[ \r\n\t]/) : void 0) {
        results.push(this.pos++);
      }
      return results;
    };

    Parser.prototype.isEOF = function() {
      return this.pos === this.code.length;
    };

    Parser.prototype.currentPos = function() {
      var headToCurrent;
      headToCurrent = this.code.substr(0, this.pos);
      return {
        row: headToCurrent.split("\n").length,
        column: this.pos - headToCurrent.lastIndexOf("\n") - 1
      };
    };

    Parser.prototype.expects = function(pattern, throwing) {
      var token, valid;
      if (throwing == null) {
        throwing = false;
      }
      valid = this.code[this.pos] && (pattern instanceof RegExp && pattern.test(this.code[this.pos])) || pattern === this.code.slice(this.pos, this.pos + pattern.length);
      if (!valid && throwing) {
        token = this.isEOF() ? 'EOF' : this.code[this.pos];
        error(ParseError, "unexpected \"" + token + "\", expects \"" + pattern + "\"", this.currentPos());
      }
      return valid;
    };

    Parser.prototype.expects_token = function(token) {
      return this.code[this.pos] && token === this.code.slice(this.pos, this.pos + token.length) && !SYMBOL_PATTERN.test(this.code[this.pos + token.length]);
    };

    Parser.prototype.forwards = function(pattern) {
      this.expects(pattern, true);
      return this.pos += pattern instanceof RegExp ? 1 : pattern.length;
    };

    Parser.prototype.forwards_if = function(pattern) {
      if (this.expects(pattern)) {
        return this.forwards(pattern);
      }
    };

    Parser.prototype.atom = function(quoted) {
      var num, str;
      if (this.expects(/[0-9]/)) {
        num = '';
        while (this.expects(/[0-9]/)) {
          num += this.code[this.pos++];
        }
        return parseInt(num);
      }
      if (this.forwards_if('"')) {
        str = '';
        while (!this.expects('"')) {
          str += this.code[this.pos++];
        }
        this.forwards('"');
        return str;
      }
      if (this.expects_token('nil')) {
        this.forwards('nil');
        return nil;
      }
      if (this.expects_token('t')) {
        this.forwards('t');
        return t;
      }
      return new Symbol(this.symbol(), quoted, this.currentPos());
    };

    Parser.prototype.symbol = function() {
      var ret;
      ret = '';
      while (this.expects(SYMBOL_PATTERN)) {
        ret += this.code[this.pos++];
      }
      return ret;
    };

    Parser.prototype.list = function() {
      var values;
      this.forwards('(');
      values = [];
      while (!(this.expects(')') || this.isEOF())) {
        values.push(this.expr());
        this.skip();
      }
      this.forwards(')');
      return new List(values);
    };

    Parser.prototype.call_fun = function() {
      var args, funname;
      this.forwards('(');
      args = [];
      funname = this.expr();
      while (!(this.expects(')') || this.isEOF())) {
        this.skip();
        args.push(this.expr());
      }
      this.forwards(')');
      return new CallFun(funname, args);
    };

    Parser.prototype.expr = function() {
      if (this.forwards_if("'")) {
        if (this.expects('(')) {
          return this.list();
        } else {
          return this.atom(true);
        }
      } else if (this.expects('(')) {
        return this.call_fun();
      } else {
        return this.atom(false);
      }
    };

    Parser.prototype.program = function() {
      var ret;
      ret = [];
      while (!this.isEOF()) {
        this.skip();
        ret.push(this.expr());
      }
      return ret;
    };

    Parser.prototype.parse = function(code1) {
      this.code = code1;
      this.pos = 0;
      return this.program();
    };

    return Parser;

  })();

  Evaluator = (function() {
    function Evaluator() {}

    Evaluator.prototype.exec_lambda = function(lambda, args) {
      var ret;
      envstack.push(new Environment(lambda.params.values.reduce((function(env, param, index) {
        env[param.name] = args[index];
        return env;
      }), {})));
      ret = lambda.exprs.map((function(_this) {
        return function(expr) {
          return _this.eval_expr(expr);
        };
      })(this))[0];
      envstack.pop();
      return ret;
    };

    Evaluator.prototype.eval_expr = function(expr) {
      var BASIC_FUNCTIONS, SPECIAL_FORMS, args, func, funname, lambda, macro, sf, value;
      switch (expr.constructor.name) {
        case 'CallFun':
          args = expr.args;
          SPECIAL_FORMS = {
            'cond': (function(_this) {
              return function() {
                var arg, i, len;
                for (i = 0, len = args.length; i < len; i++) {
                  arg = args[i];
                  if (!(_this.eval_expr(arg.values[0]) instanceof Nil)) {
                    return arg.values[1];
                  }
                }
                return nil;
              };
            })(this),
            'quote': function() {
              return args[0];
            },
            'lambda': function() {
              return new Lambda(args[0], args.slice(1));
            },
            'defun': function() {
              return currentEnv().set(args[0].name, new Lambda(args[1], args.slice(2)));
            },
            'setq': (function(_this) {
              return function() {
                var value;
                value = _this.eval_expr(args[1]);
                return currentEnv().set(args[0].name, value);
              };
            })(this),
            'defmacro': function() {
              return currentEnv().setMacro(args[0].name, new Lambda(args[1], args.slice(2)));
            },
            'let': (function(_this) {
              return function() {
                return _this.exec_lambda(new Lambda(new List(args[0].values.map(function(pair) {
                  return pair.values[0];
                })), args.slice(1)), args[0].values.map(function(pair) {
                  return pair.values[1];
                }));
              };
            })(this)
          };
          BASIC_FUNCTIONS = {
            'list': function() {
              var name, ref;
              ref = args, name = ref[0], args = 2 <= ref.length ? slice.call(ref, 1) : [];
              return new CallFun(name, args);
            },
            '+': function() {
              return args.reduce((function(sum, n) {
                return sum + n;
              }), 0);
            },
            '-': function() {
              return args.slice(1).reduce((function(sub, n) {
                return sub - n;
              }), args[0]);
            },
            '*': function() {
              return args.reduce((function(mul, n) {
                return mul * n;
              }), 1);
            },
            '/': function() {
              return args.slice(1).reduce((function(div, n) {
                return div / n;
              }), args[0]);
            },
            'car': function() {
              if (args[0] instanceof Nil) {
                return nil;
              } else {
                return args[0].values[0];
              }
            },
            'cdr': function() {
              if (args[0] instanceof Nil) {
                return nil;
              } else {
                return new List(args[0].values.slice(1));
              }
            },
            'cons': function() {
              return new List([args[0]].concat(slice.call(args[1].values)));
            },
            'eq': function() {
              if (args[0] === args[1]) {
                return t;
              } else {
                return nil;
              }
            },
            'atom': function() {
              if (isAtom(args[0])) {
                return t;
              } else {
                return nil;
              }
            }
          };
          funname = expr.funname;
          if (funname.constructor.name === 'Lambda') {
            return this.exec_lambda(funname);
          }
          if (sf = SPECIAL_FORMS[funname.name]) {
            return sf();
          }
          args = !currentEnv().getMacro(funname.name) ? expr.args.map((function(_this) {
            return function(arg) {
              return _this.eval_expr(arg);
            };
          })(this)) : expr.args;
          if (func = BASIC_FUNCTIONS[funname.name]) {
            return func();
          }
          if (macro = currentEnv().getMacro(funname.name)) {
            expr = this.exec_lambda(macro, args);
            return this.eval_expr(expr);
          }
          if (lambda = currentEnv().get(funname.name)) {
            return this.exec_lambda(lambda, args);
          }
          if (funname.constructor.name !== 'Symbol') {
            error(NotFunctionError, (funname.toString()) + "(" + funname.constructor.name + ") is not a function", funname.pos);
          }
          return error(NameError, "undefined function \"" + funname.name + "\"", funname.pos);
        case 'Symbol':
          if (expr.quoted) {
            return expr;
          }
          value = currentEnv().get(expr.name);
          if (!value) {
            error(NameError, "undefined valiable \"" + expr.name + "\"", expr.pos);
          }
          return value;
        default:
          return expr;
      }
    };

    Evaluator.prototype["eval"] = function(ast) {
      var expr;
      envstack.push(new Environment({}));
      return ((function() {
        var i, len, results;
        results = [];
        for (i = 0, len = ast.length; i < len; i++) {
          expr = ast[i];
          results.push(this.eval_expr(expr));
        }
        return results;
      }).call(this)).pop().toString();
    };

    return Evaluator;

  })();

  this.Lisp = (function() {
    function Lisp() {}

    Lisp["eval"] = function(code) {
      var ast;
      ast = (new Parser).parse(code);
      return {
        ast: ast,
        body: (new Evaluator)["eval"](ast)
      };
    };

    return Lisp;

  })();

  if (typeof $ !== "undefined" && $ !== null) {
    $(function() {
      return $('script[type="text/lisp"]').each(function() {
        return Lisp["eval"]($(this).text());
      });
    });
  }

}).call(this);
