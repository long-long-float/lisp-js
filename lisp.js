// Generated by CoffeeScript 1.7.1
var CallFun, Environment, Evaluator, Lambda, LispError, List, NameError, Nil, NotFunctionError, ParseError, SF_NAMES, SpecialForm, Symbol, T, currentEnv, envstack, error, isAtom, nil, t,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  __slice = [].slice;

Symbol = (function() {
  function Symbol(name, pos) {
    this.name = name;
    this.pos = pos;
  }

  Symbol.prototype.toString = function() {
    return this.name;
  };

  return Symbol;

})();

Nil = (function() {
  function Nil() {}

  Nil.prototype.toString = function() {
    return 'nil';
  };

  return Nil;

})();

nil = new Nil;

T = (function() {
  function T() {}

  T.prototype.toString = function() {
    return 't';
  };

  return T;

})();

t = new T;

List = (function() {
  function List(values) {
    this.values = values;
  }

  List.prototype.toString = function() {
    return "(" + (this.values.map(function(v) {
      return v.toString();
    }).join(' ')) + ")";
  };

  return List;

})();

CallFun = (function() {
  function CallFun(funname, args) {
    this.funname = funname;
    this.args = args;
  }

  CallFun.prototype.toString = function() {
    return "(" + this.funname + " " + (this.values.map(function(v) {
      return v.toString();
    }).join(' ')) + ")";
  };

  return CallFun;

})();

SF_NAMES = ['cond', 'quote', 'lambda', 'defun'];

SpecialForm = (function() {
  function SpecialForm(name, args) {
    this.name = name;
    this.args = args;
  }

  SpecialForm.prototype.toString = function() {
    return "(" + this.name + " " + (this.args.map(function(v) {
      return v.toString();
    }).join(' ')) + ")";
  };

  return SpecialForm;

})();

Lambda = (function() {
  function Lambda(params, body) {
    this.params = params;
    this.body = body;
  }

  return Lambda;

})();

Environment = (function() {
  function Environment(variables) {
    this.variables = variables;
  }

  Environment.prototype.get = function(name) {
    return this.variables[name];
  };

  Environment.prototype.set = function(name, val) {
    return this.variables[name] = val;
  };

  return Environment;

})();

LispError = (function(_super) {
  __extends(LispError, _super);

  function LispError(message) {
    this.message = message;
    this.name = this.constructor.name;
  }

  LispError.prototype.toString = function() {
    return "[object: " + this.name + "]";
  };

  return LispError;

})(Error);

ParseError = (function(_super) {
  __extends(ParseError, _super);

  function ParseError() {
    return ParseError.__super__.constructor.apply(this, arguments);
  }

  return ParseError;

})(LispError);

NameError = (function(_super) {
  __extends(NameError, _super);

  function NameError() {
    return NameError.__super__.constructor.apply(this, arguments);
  }

  return NameError;

})(LispError);

NotFunctionError = (function(_super) {
  __extends(NotFunctionError, _super);

  function NotFunctionError() {
    return NotFunctionError.__super__.constructor.apply(this, arguments);
  }

  return NotFunctionError;

})(LispError);

isAtom = function(val) {
  return typeof val === 'string' || typeof val === 'number' || val instanceof Nil || val instanceof T;
};

envstack = [];

currentEnv = function() {
  if (!(envstack.length > 0)) {
    throw "envstack is empty";
  }
  return envstack[envstack.length - 1];
};

error = function(klass, msg, pos) {
  throw new klass(("" + msg) + (pos != null ? " at " + pos.row + ":" + pos.column : ""));
};

this.Parser = (function() {
  function Parser() {}

  Parser.prototype.skip = function() {
    var _ref, _results;
    _results = [];
    while ((_ref = this.code[this.pos]) != null ? _ref.match(/[ \r\n\t]/) : void 0) {
      _results.push(this.pos++);
    }
    return _results;
  };

  Parser.prototype.isEOF = function() {
    return this.pos === this.code.length;
  };

  Parser.prototype.currentPos = function() {
    var headToCurrent;
    headToCurrent = this.code.substr(0, this.pos);
    return {
      row: headToCurrent.split("\n").length,
      column: this.pos - headToCurrent.lastIndexOf("\n") - 1
    };
  };

  Parser.prototype.expects = function(pattern, throwing) {
    var token, valid;
    if (throwing == null) {
      throwing = false;
    }
    valid = this.code[this.pos] && (pattern instanceof RegExp && pattern.test(this.code[this.pos])) || pattern === this.code.slice(this.pos, this.pos + pattern.length);
    if (!valid && throwing) {
      token = this.isEOF() ? 'EOF' : this.code[this.pos];
      error(ParseError, "unexpected \"" + token + "\", expects \"" + pattern + "\"", this.currentPos());
    }
    return valid;
  };

  Parser.prototype.forwards = function(pattern) {
    this.expects(pattern, true);
    this.code[this.pos];
    return this.pos += pattern instanceof RegExp ? 1 : pattern.length;
  };

  Parser.prototype.forwards_if = function(pattern) {
    if (this.expects(pattern)) {
      return this.forwards(pattern);
    }
  };

  Parser.prototype.atom = function() {
    var num, str;
    if (this.expects(/[0-9]/)) {
      num = '';
      while (this.expects(/[0-9]/)) {
        num += this.code[this.pos++];
      }
      return parseInt(num);
    }
    if (this.forwards_if('"')) {
      str = '';
      while (!this.expects('"')) {
        str += this.code[this.pos++];
      }
      this.forwards('"');
      return str;
    }
    if (this.forwards_if('nil')) {
      return nil;
    }
    if (this.forwards_if('t')) {
      return t;
    }
    return new Symbol(this.symbol(), this.currentPos());
  };

  Parser.prototype.symbol = function() {
    var ret;
    ret = '';
    while (this.expects(/[\w!#$%&=-~^|*+<>?_]/)) {
      ret += this.code[this.pos++];
    }
    return ret;
  };

  Parser.prototype.list = function() {
    var values;
    this.forwards('(');
    values = [];
    while (!(this.expects(')') || this.isEOF())) {
      values.push(this.expr());
      this.skip();
    }
    this.forwards(')');
    return new List(values);
  };

  Parser.prototype.call_fun = function() {
    var args, funname, isSF, klass;
    this.forwards('(');
    args = [];
    funname = this.expr();
    isSF = SF_NAMES.indexOf(funname.name) !== -1;
    while (!(this.expects(')') || this.isEOF())) {
      this.skip();
      args.push(this.expr(isSF));
    }
    this.forwards(')');
    klass = isSF ? SpecialForm : CallFun;
    return new klass(funname, args);
  };

  Parser.prototype.expr = function(isSF) {
    if (this.expects("'") || isSF) {
      if (!isSF) {
        this.forwards("'");
      }
      if (this.expects('(')) {
        return this.list();
      } else {
        return this.atom();
      }
    } else if (this.expects('(')) {
      return this.call_fun();
    } else {
      return this.atom();
    }
  };

  Parser.prototype.program = function() {
    var ret;
    ret = [];
    while (!this.isEOF()) {
      this.skip();
      ret.push(this.expr());
    }
    return ret;
  };

  Parser.prototype.parse = function(code) {
    this.code = code;
    this.pos = 0;
    return this.program();
  };

  return Parser;

})();

Evaluator = (function() {
  function Evaluator() {}

  Evaluator.prototype.exec_lambda = function(lambda, args) {
    var name, ret, _ref;
    envstack.push(new Environment(lambda.params.values.reduce((function(env, param, index) {
      env[param.name] = args[index];
      return env;
    }), {})));
    _ref = lambda.body.values, name = _ref[0], args = 2 <= _ref.length ? __slice.call(_ref, 1) : [];
    ret = this.eval_expr(new CallFun(name, args));
    envstack.pop();
    return ret;
  };

  Evaluator.prototype.eval_expr = function(expr) {
    var args, funcs, funname, funs, lambda;
    switch (expr.constructor.name) {
      case 'SpecialForm':
        args = expr.args;
        return {
          'cond': (function(_this) {
            return function() {
              var arg, _i, _len;
              for (_i = 0, _len = args.length; _i < _len; _i++) {
                arg = args[_i];
                if (!(_this.eval_expr(arg.values[0]) instanceof Nil)) {
                  return arg.values[1];
                }
              }
              return nil;
            };
          })(this),
          'quote': function() {
            return args[0];
          },
          'lambda': function() {
            return new Lambda(args[0], args[1]);
          },
          'defun': function() {
            return currentEnv().set(args[0].name, new Lambda(args[1], args[2]));
          }
        }[expr.name.name]();
      case 'CallFun':
        args = expr.args.map((function(_this) {
          return function(arg) {
            return _this.eval_expr(arg);
          };
        })(this));
        funname = expr.funname instanceof SpecialForm ? this.eval_expr(expr.funname) : expr.funname;
        switch (funname.constructor.name) {
          case 'Lambda':
            return this.exec_lambda(funname);
          case 'Symbol':
            funcs = {
              '+': function() {
                return args.reduce((function(sum, n) {
                  return sum + n;
                }), 0);
              },
              'car': function() {
                return args[0].values[0];
              },
              'cdr': function() {
                return new List(args[0].values.slice(1));
              },
              'cons': function() {
                return new List([args[0]].concat(__slice.call(args[1].values)));
              },
              'eq': function() {
                if (args[0] === args[1]) {
                  return t;
                } else {
                  return nil;
                }
              },
              'atom': function() {
                if (isAtom(args[0])) {
                  return t;
                } else {
                  return nil;
                }
              }
            };
            if (funs = funcs[funname.name]) {
              return funs();
            } else {
              if (lambda = currentEnv().get(funname.name)) {
                return this.exec_lambda(lambda, args);
              } else {
                return error(NameError, "undefined function \"" + funname.name + "\"", funname.pos);
              }
            }
            break;
          default:
            return error(NotFunctionError, "" + (JSON.stringify(funname)) + "(" + funname.constructor.name + ") is not a function", funname.pos);
        }
        break;
      case 'Symbol':
        return currentEnv().get(expr.name);
      default:
        return expr;
    }
  };

  Evaluator.prototype["eval"] = function(ast) {
    var expr;
    envstack.push(new Environment({}));
    return ((function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = ast.length; _i < _len; _i++) {
        expr = ast[_i];
        _results.push(this.eval_expr(expr));
      }
      return _results;
    }).call(this)).pop().toString();
  };

  return Evaluator;

})();

this.Lisp = (function() {
  function Lisp() {}

  Lisp["eval"] = function(code) {
    var ast;
    ast = (new Parser).parse(code);
    return {
      ast: ast,
      body: (new Evaluator)["eval"](ast)
    };
  };

  return Lisp;

})();

if (typeof $ !== "undefined" && $ !== null) {
  $(function() {
    return $('script[type="text/lisp"]').each(function() {
      return Lisp["eval"]($(this).text());
    });
  });
}
