// Generated by CoffeeScript 1.7.1
(function() {
  var Atom, CallFun, Evaluator, List, Nil, Parser, merge,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  merge = function() {
    var arg, args, item, ret, _i, _len;
    args = Array.prototype.slice.call(arguments);
    ret = {};
    for (_i = 0, _len = args.length; _i < _len; _i++) {
      arg = args[_i];
      for (item in arg) {
        if (arg.hasOwnProperty(item)) {
          ret[item] = arg[item];
        }
      }
    }
    return ret;
  };

  Atom = (function() {
    function Atom(value) {
      this.value = value;
    }

    return Atom;

  })();

  Nil = (function(_super) {
    __extends(Nil, _super);

    function Nil() {
      return Nil.__super__.constructor.apply(this, arguments);
    }

    return Nil;

  })(Atom);

  List = (function() {
    function List(values, as_data) {
      this.values = values;
      this.as_data = as_data;
    }

    return List;

  })();

  CallFun = (function() {
    function CallFun(funname, args) {
      this.funname = funname;
      this.args = args;
    }

    return CallFun;

  })();

  Parser = (function() {
    function Parser() {}

    Parser.prototype.getChar = function() {
      return this.code[this.pos];
    };

    Parser.prototype.skip = function() {
      var _ref, _results;
      _results = [];
      while ((_ref = this.getChar()) != null ? _ref.match(/[ ]/) : void 0) {
        _results.push(this.pos++);
      }
      return _results;
    };

    Parser.prototype.isEOF = function() {
      return this.pos === this.code.length;
    };

    Parser.prototype.expects = function(pattern, throwing) {
      var valid;
      if (throwing == null) {
        throwing = true;
      }
      valid = (pattern instanceof RegExp && pattern.test(this.getChar())) || pattern === this.getChar();
      if (!valid && throwing) {
        throw "unexpected \"" + (this.getChar()) + "\", expects \"" + pattern + "\"";
      }
      return valid;
    };

    Parser.prototype.expects_str = function(str, throwing) {
      var valid;
      if (throwing == null) {
        throwing = true;
      }
      return valid = this.code.slice(this.pos, this.pos + str.length) === str;
    };

    Parser.prototype.forwards = function(pattern) {
      this.expects(pattern);
      return this.pos++;
    };

    Parser.prototype.forwards_str = function(str) {
      this.expects_str(str);
      return this.pos += str.length;
    };

    Parser.prototype.atom = function() {
      var c, num, str;
      c = this.getChar();
      if (this.expects(/[0-9]/, false)) {
        num = '';
        while (this.expects(/[0-9]/, false)) {
          num += this.getChar();
          this.pos++;
        }
        return new Atom(parseInt(num));
      }
      if (this.expects('"', false)) {
        this.forwards('"');
        str = '';
        while (!this.expects('"', false)) {
          str += this.getChar();
          this.pos++;
        }
        this.forwards('"');
        return new Atom(str);
      }
      if (this.expects_str('nil', false)) {
        this.forwards_str('nil');
        return new Nil;
      }
    };

    Parser.prototype.fun_name = function() {
      var ret;
      ret = '';
      while (this.expects(/[\w!#$%&=-~^|*+<>?_]/, false)) {
        ret += this.getChar();
        this.pos++;
      }
      return ret;
    };

    Parser.prototype.list = function() {
      var values;
      this.forwards('(');
      values = [];
      while (!this.expects(')', false)) {
        values.push(this.expr());
        this.skip();
      }
      this.forwards(')');
      return new List(values);
    };

    Parser.prototype.call_fun = function() {
      var args, funname;
      this.forwards('(');
      args = [];
      funname = this.fun_name();
      while (!this.expects(')', false)) {
        this.skip();
        args.push(this.expr());
      }
      this.forwards(')');
      return new CallFun(funname, args);
    };

    Parser.prototype.expr = function() {
      if (this.expects("'", false)) {
        this.forwards("'");
        if (this.expects('(', false)) {
          return this.list();
        } else {
          return this.atom();
        }
      } else if (this.expects('(', false)) {
        return this.call_fun();
      } else {
        return this.atom();
      }
    };

    Parser.prototype.program = function() {
      var ret;
      ret = [];
      while (!this.isEOF()) {
        ret.push(this.expr());
      }
      return ret;
    };

    Parser.prototype.parse = function(code) {
      this.code = code;
      this.pos = 0;
      return this.program();
    };

    return Parser;

  })();

  Evaluator = (function() {
    function Evaluator() {}

    Evaluator.prototype["eval"] = function(ast) {};

    return Evaluator;

  })();

  this.Lisp = (function() {
    function Lisp() {}

    Lisp["eval"] = function(code, opts) {
      var ast, ret;
      opts = merge({
        ast: false
      }, opts);
      ast = (new Parser).parse(code);
      ret = {};
      if (opts.ast) {
        ret.ast = ast;
      }
      ret.body = (new Evaluator)["eval"](ast);
      return ret;
    };

    return Lisp;

  })();

}).call(this);
